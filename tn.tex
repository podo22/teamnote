\documentclass[landscape, 8pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}
\usepackage{ifthen}
\usepackage{teamnote}
\usepackage{listings}
\usepackage{xcolor}
\raggedbottom
\usepackage{fontspec}
\usepackage{kotex}
\setmonofont{Monoplex KR SemiBold}

\teamnote{A University}{A Team}{A, B, C}

\ShowUsage
\ShowComplexity
\HideAuthor
\usepackage{etoolbox}

\begin{document}

\maketitlepage

\section{Basic Implementation}
\Algorithm{Main Template}{}{}{cpp}{source/0. Basic Implementation/main.cpp}{}

\section{Math}
\Algorithm{Basic Arithmetic}{}{}{cpp}{source/1. Math/Basic arithmetic.cpp}{}
\Algorithm{Binomial Coefficient}{}{first: $O(1)$ / second: $O(\sum p^k)$}{cpp}{source/1. Math/Binomial Coefficient.cpp}{}
\Algorithm{Chinese Remainder Theorem}{Solve system of linear congruences.}{$O(\log N)$}{cpp}{source/1. Math/Chinese remainder theorem.cpp}{}
\Algorithm{FFT \& NTT}{Fast Fourier/Number Theoretic Transform for convolutions.}{$O(N \log N)$}{cpp}{source/1. Math/FFT + NTT.cpp}{}
\Algorithm{Linear Sieve}{Find primes and multiplicative functions in linear time.}{$O(N)$}{cpp}{source/1. Math/Linear Sieve.cpp}{}
\Algorithm{Miller-Rabin \& Pollard-Rho}{Primality test and integer factorization.}{$O(\log^3 N) / O(N^{1/4})$}{cpp}{source/1. Math/Miller rabin + Pollard rho.cpp}{}

\section{Data Structure}
\Algorithm{Erasable Priority Queue}{}{}{cpp}{source/2. Data structure/Erasable PQ.cpp}{}
\Algorithm{Non-Recursive Segment Tree}{}{$O(\log N)$ per query}{cpp}{source/2. Data structure/NonRec_SegTree.cpp}{}
\Algorithm{Merge Sort Tree}{Count/rank of elements in range $[L, R]$.}{$O(\log^2 N)$ per query}{cpp}{source/2. Data structure/MergeSortTree.cpp}{}
\Algorithm{Persistent Segment Tree}{Accessing previous versions and range k-th element.}{$O(\log N)$ per query}{cpp}{source/2. Data structure/PersistentSegmentTree.cpp}{}
\Algorithm{Sweepline Mo's}{Optimized Mo's for $O(1)$ update and $O(1)$ query via offline sweepline.}{$O(N\sqrt{Q})$}{cpp}{source/2. Data structure/Sweepline MOs.cpp}{}

\section{Graph}
\Algorithm{Bellman Ford}{SSSP with negative weights/cycles.}{$O(VE)$}{cpp}{source/3. Graph/Bellman.cpp}{}
\Algorithm{SPFA (SLF Optimized)}{SSSP with negative weights. Returns false if negative cycle detected.}{Avg $O(E)$, Worst $O(VE)$}{cpp}{source/3. Graph/SPFA.cpp}{}
\Algorithm{LCA}{Lowest Common Ancestor using binary lifting.}{$O(\log N)$}{cpp}{source/3. Graph/LCA.cpp}{}
\Algorithm{HLD}{Heavy-Light Decomposition for path queries on trees.}{$O(\log^2 N)$}{cpp}{source/3. Graph/HLD.cpp}{}
\Algorithm{Centroid Decomposition}{Divide and conquer on trees for path/distance problems.}{$O(N \log N)$ build}{cpp}{source/3. Graph/Centroid Decomposition.cpp}{}
\Algorithm{Bipartite Matching}{Maximum matching in bipartite graphs.}{$O(E\sqrt{V})$}{cpp}{source/3. Graph/Bipartite_Matching.cpp}{}
\Algorithm{Dinic}{Efficient maximum flow algorithm.}{$O(V^2E)$}{cpp}{source/3. Graph/Dinic.cpp}{}
\Algorithm{MCMF}{Minimum Cost Maximum Flow using SPFA.}{$O(F \cdot E \log V)$}{cpp}{source/3. Graph/MCMF.cpp}{}
\Algorithm{Circulation}{Flow with lower and upper bounds.}{}{cpp}{source/3. Graph/Circulation.cpp}{}
\Algorithm{SCC}{Strongly Connected Components.}{$O(V+E)$}{cpp}{source/3. Graph/SCC.cpp}{}
\Algorithm{BCC}{Biconnected Components, Cut-vertices, and Bridges.}{$O(V+E)$}{cpp}{source/3. Graph/BCC.cpp}{}

\section{DP Optimization}
\Algorithm{Convex Hull Trick}{\texttt{dp[i] = min(dp[j] + b[j] * a[i]), b[j] >= b[j+1]}}{$O(N \log N)$}{cpp}{source/4. DP/Convex Hull Trick.cpp}{}
\Algorithm{Linear CHT}{CHT when slopes/queries are monotonic.}{$O(N)$}{cpp}{source/4. DP/Linear CHT.cpp}{}
\Algorithm{D\&C optimization}{\texttt{dp[t][i] = min(dp[t-1][j] + c[j][i]), c is Monge}}{$O(KN \log N)$}{cpp}{source/4. DP/DNC opt.cpp}{}
\Algorithm{Monotone Queue optimization}{\texttt{dp[i] = min(dp[j] + c[j][i]), c is Monge, find cross}}{$O(N\log{N})$}{cpp}{source/4. DP/MonotoneQueue opt.cpp}{}
\Algorithm{Aliens Trick}{\texttt{dp[t][i] = min(dp[t-1][j] + c[j+1][i]), c is Monge, find lambda w/ half bs}}{$O(T \log X)$}{cpp}{source/4. DP/Aliens.cpp}{}
\Algorithm{Sum Over Subsets}{\texttt{dp[mask] = sum(A[i]), i is in mask}}{$O(N2^N)$}{cpp}{source/4. DP/SumOverSubsets.cpp}{}
\Algorithm{Berlekamp Massey}{Linear recurrence $N$-th term. Sparse matrix determinant.}{$N$-th term: $O(K^2 \log N)$ / Det: $O(N(N+E))$}{cpp}{source/4. DP/Berlekamp_massey.cpp}{}

\section{Geometry}
\Algorithm{Geometry Template}{Basic point, line, and circle operations.}{}{cpp}{source/5. Geometry/Basic Template.cpp}{}
\Algorithm{Convex Hull}{Finds the convex hull using Monotone Chain. Returns vertices in CCW order.}{$O(N \log N)$}{cpp}{source/5. Geometry/ConvexHull.cpp}{}
\Algorithm{Rotating Calipers}{Calculates the diameter (farthest pair of points) of a convex hull(CCW order).}{$O(N)$}{cpp}{source/5. Geometry/Calipers.cpp}{}
\Algorithm{Point in Convex Polygon}{Checks if a point is inside or on the boundary of a convex polygon (CCW sorted).}{$O(\log N)$}{cpp}{source/5. Geometry/PointInConvexPolygon.cpp}{}
\Algorithm{Point in Polygon}{Ray casting algorithm for general polygons.}{$O(N)$}{cpp}{source/5. Geometry/PointInPolygon.cpp}{}
\Algorithm{Sort Points}{Angular sort. 1. Relative to pivot (Convex Hull). 2. Relative to origin.}{}{cpp}{source/5. Geometry/SortPoints.cpp}{}
\Algorithm{Linear Minkowski Sum}{Minkowski Sum of Two convex(must be CCW order).}{$O(N+M)$}{cpp}{source/5. Geometry/LinearMinkowski.cpp}{}
\Algorithm{Polygon Area}{Calculates 2 $\times$ Area of a polygon (Shoelace formula).}{$O(N)$}{cpp}{source/5. Geometry/PolygonArea.cpp}{}
\Algorithm{Smallest Enclosing Circle}{Welzl's algorithm to find the Minimum Enclosing Circle. Returns {center, radius}.}{Expected $O(N)$}{cpp}{source/5. Geometry/EnclosingCircle.cpp}{}
\Algorithm{Geometric Intersections}{Intersection primitives: Segment, Line-Circle, Line-Hull, and Circle-Polygon area.}{$O(1) / O(1) / O(\log N) / O(N)$}{cpp}{source/5. Geometry/Intersect.cpp}{}
\Algorithm{Half Plane Intersection}{Intersection of half-planes defined by lines (left side is valid). Returns a convex polygon.}{$O(N \log N)$}{cpp}{source/5. Geometry/HalfPlaneIntersect.cpp}{}

\section{String}
\Algorithm{Aho-Corasick}{Multi-pattern matching using trie and failure links.}{$O(\sum |P| + |T|)$}{cpp}{source/6. String/Aho-Corasick.cpp}{}
\Algorithm{Hashing}{Rolling hash for string matching.}{$O(N)$}{cpp}{source/6. String/Hashing.cpp}{}
\Algorithm{KMP}{Single pattern matching using prefix function.}{$O(N+M)$}{cpp}{source/6. String/KMP.cpp}{}
\Algorithm{Manacher}{Find all palindromic substrings in linear time.}{$O(N)$}{cpp}{source/6. String/Manacher.cpp}{}
\Algorithm{Suffix Array}{Suffix array and LCP array construction.}{$O(N \log N)$}{cpp}{source/6. String/SuffixArray.cpp}{}
\Algorithm{Z-algorithm}{Longest common prefix between S and its suffixes.}{$O(N)$}{cpp}{source/6. String/Z.cpp}{}

\section{STL \& pbds}
\Algorithm{Hash map (pb\_ds)}{Faster hash table using pb\_ds.}{$O(1)$}{cpp}{source/7. STL + pbds/Hash map(pbds).cpp}{}
\Algorithm{Ordered Set (pb\_ds)}{Set supporting order\_of\_key and find\_by\_order.}{$O(\log N)$}{cpp}{source/7. STL + pbds/Ordered Set(pbds).cpp}{}
\Algorithm{Permutation \& Combination}{next\_permutation and mask-based combinations.}{}{cpp}{source/7. STL + pbds/Permutation + Combination.cpp}{}
\Algorithm{Priority Queue (pb\_ds)}{Meldable heap supporting modify/erase via point\_iterator.}{$O(\log N)$}{cpp}{source/7. STL + pbds/Priority queue(pbds).cpp}{}
\Algorithm{Rope}{Persistent sequence supporting fast insertion, deletion and slicing.}{$O(\log N)$}{cpp}{source/7. STL + pbds/Rope.cpp}{}
\Algorithm{Trie (pb\_ds)}{Prefix tree implementation from pb\_ds.}{}{cpp}{source/7. STL + pbds/Trie(pbds).cpp}{}

\section{Misc}
\Algorithm{Custom Hash}{Custom hash for pair, vector.}{}{cpp}{source/8. Misc/Custom hash.cpp}{}
\Algorithm{Fast I/O}{Fast integer I/O using fread/fwrite.}{}{cpp}{source/8. Misc/Fastio.cpp}{}
\Algorithm{Random}{Better random for mt19937.}{}{cpp}{source/8. Misc/Random.cpp}{}
\Algorithm{Ternary Search}{Finding extremum of unimodal functions.}{$O(\log N)$}{cpp}{source/8. Misc/Ternary search.cpp}{}
\Algorithm{Some tricks}{Collection of bitwise hacks and optimization techniques.}{}{cpp}{source/8. Misc/Some tricks.cpp}{}

\section{Checklist + Useful Info}

\Algorithm{Highly Composite Numbers, Large Prime}{}{}{}{}{}
\input{source/8. Misc/Primes}

\Algorithm{Useful Stuff}{}{}{}{}{}
\begin{itemize}
    \item Catalan Number\\
          1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900\\
          $C_n = \binom{2n}{n} / (n + 1);$\\
          - 길이가 2n인 올바른 괄호 수식의 수\\
          - n + 1개의 리프를 가진 풀 바이너리 트리의 수\\
          - n + 2각형을 n개의 삼각형으로 나누는 방법의 수
    \item Burnside’s Lemma\\
          경우의 수를 세는데, 특정 transform operation(회전, 반사, ..) 해서 같은 경우들은 하나로 친다. 전체 경우의 수는? 각 operation마다 이 operation을 했을 때 변하지 않는 경우의 수를 센다 (단, “아무것도 하지 않는다” 라는 operation도 있어야 함!) 전체 경우의 수를 더한 후, operation의 수로 나눈다. (답이 맞다면 항상 나누어 떨어져야 한다)
    \item 알고리즘 게임\\
          - Nim Game의 해법 : 각 더미의 돌의 개수를 모두 XOR했을 때 0 이 아니면 첫번째, 0 이면 두번째 플레이어가 승리.\\
          - Grundy Number : 어떤 상황의 Grundy Number는, 가능한 다음 상황들의 Grundy Number를 모두 모은 다음, 그 집합에 포함 되지 않는 가장 작은 수가 현재 state의 Grundy Number가 된다. 만약 다음 state가 독립된 여러개의 state들로 나뉠 경우, 각각의 state의 Grundy Number의 XOR 합을 생각한다.\\
          - Subtraction Game : 한 번에 k 개까지의 돌만 가져갈 수 있는 경우, 각 더미의 돌의 개수를 k + 1로 나눈 나머지를 XOR 합하여 판단한다.\\
          - Index-k Nim : 한 번에 최대 k개의 더미를 골라 각각의 더미에서 아무렇게나 돌을 제거할 수 있을 때, 각 binary digit에 대하여 합을 k + 1로 나눈 나머지를 계산한다. 만약 이 나머지가 모든 digit에 대하여 0이라면 두번째, 하나라도 0이 아니라면 첫번째 플레이어가 승리.
          - Misere Nim : 모든 돌 무더기가 1이면 N이 홀수일 때 후공 승, 그렇지 않은 경우 XOR 합 0이면 후공 승
    \item Pick’s Theorem\\
          격자점으로 구성된 simple polygon이 주어짐. I 는 polygon 내부의 격자점 수, B 는 polygon 선분 위 격자점 수, A는 polygon의 넓이라고 할 때, 다음과 같은 식이 성립한다. $A=I+B/2-1$
    \item 가장 가까운 두 점 : 분할정복으로 가까운 6개의 점만 확인
    \item 홀의 결혼 정리 : 이분그래프(L-R)에서, 모든 L을 매칭하는 필요충분 조건 = L에서 임의의 부분집합 S를 골랐을 때, 반드시 (S의 크기) $\le$ (S와 연결되어있는 모든 R의 크기)이다.
    \item 소수 : 10 007 , 10 009 , 10 111 , 31 567 , 70 001 , 1 000 003 , 1 000 033 , 4 000 037 , 99 999 989 , 999 999 937 , 1 000 000 007 , 1 000 000 009 , 9 999 999 967 , 99 999 999 977
    \item 소수 개수 : (1e5 이하 : 9592), (1e7 이하 : 664 579) , (1e9 이하 : 50 847 534)
    \item $10^{15}$ 이하의 정수 범위의 나눗셈 한번은 오차가 없다.
    \item N의 약수의 개수 = $O(N^{1/3})$, N의 약수의 합 = $O(N \log \log N)$
    \item $\phi(mn) = \phi(m) \phi(n) , \phi(pr^n) = pr^n - pr^{n-1} , a^{\phi(n)} \equiv 1 \pmod{n} \ \text{if coprime}$
    \item Euler characteristic : v - e + f (면, 외부 포함) = 1 + c (컴포넌트)
    \item Euler's phi $\phi (n)=n\prod _{p\mid n}\left(1-{\frac {1}{p}}\right)$
    \item Lucas' Theorem $\binom{m}{n}=\prod\binom{m_i}{n_i} \pmod p$ $m_i$, $n_i$는 $p^i$의 계수
    \item 스케줄링에서 데드라인이 빠른 걸 쓰는게 이득. 늦은 스케줄이 안들어갈 때 가장 시간 소모가 큰 스케줄 1개를 제거하면 이득.
\end{itemize}

\Algorithm{자주 쓰이는 문제 접근법}{}{}{}{}{}
\begin{itemize}
    \item 비슷한 문제를 풀어본 적이 있던가?
    \item 단순한 방법에서 시작할 수 있을까? (brute force)
    \item 내가 문제를 푸는 과정을 수식화할 수 있을까? (예제를 직접 해결해보면서)
    \item 문제를 단순화할 수 없을까? / 그림으로 그려볼 수 있을까?
    \item 수식으로 표현할 수 있을까? / 문제를 분해할 수 있을까?
    \item 뒤에서부터 생각해서 문제를 풀 수 있을까? / 순서를 강제할 수 있을까?
    \item 특정 형태의 답만을 고려할 수 있을까? (정규화)
    \item 구간을 통째로 가져간다 : 플로우 + 적당한 자료구조\\$(i,i+1,k,0),(s,e,1,w),(N,T,k,0)$
    \item 말도 안 되는 것 / 당연하다고 생각한 것 다시 생각해 보기
    \item 특수 조건을 꼭 활용 / 여사건으로 생각하기
    \item 게임이론 - 거울 전략 혹은 mex DP 연계
    \item 겁먹지 말고 경우 나누어 생각 / 해법에서 역순으로 가능한가?
    \item 딱 맞는 시간복잡도에 집착하지 말자 / 문제에 의미있는 작은 상수 이용
    \item 스몰투라지, 트라이, 해싱, 루트질 같은 트릭 생각
    \item 너무 추상화하기보단 풀려야 하는 방식으로 생각하기
    \item 잘못된 방법으로 파고들지 말고 버리자 / 제발 터널 비전에 빠지지 말자
    \item 헬프 콜은 적극적으로 / 혼자 멘탈 나가지 않기
\end{itemize}

\Algorithm{DP 최적화 접근}{}{}{}{}{}
\begin{itemize}
    \item C[i, j] = A[i] * B[j]이고 A, B가 단조증가, 단조감소이면 Monge
    \item l..r의 값들의 sum이나 min은 Monge
    \item 식 정리해서 일차(CHT) 혹은 비슷한(MQ) 함수를 발견, 구현 힘들면 Li-Chao
    \item $a \le b \le c \le d$에서 $A[a,c] + A[b,d] \le A[a,d] + A[b,c]$
    \item Monge 성질을 보이기 어려우면 $N^2$ 나이브 짜서 opt의 단조성을 확인하고 찍맞
    \item 식이 간단하거나 변수가 독립적이면 DP 테이블을 세그 위에 올려서 해결
    \item 침착하게 점화식부터 세우고 Monge인지 판별
    \item Monge에 집착하지 말고 단조성이나 볼록성만 보여도 됨
\end{itemize}

\Algorithm{Mincut 모델링}{}{}{}{}{}
\begin{itemize}
    \item $N$개의 boolean 변수 $v_1, \cdots, v_n$을 정해서 비용을 최소화하는 문제\\=true인 점은 $T$, false인 점은 $F$와 연결되게 분할하는 민컷 문제
    \begin{enumerate}
        \item $v_i$가 T일 때 비용 발생: $i$에서 F로 가는 비용 간선
        \item $v_i$가 F일 때 비용 발생: $i$에서 T로 가는 비용 간선
        \item $v_i$가 T이고 $v_j$가 F일 때 비용 발생: $i$에서 $j$로 가는 비용 간선
        \item $v_i \ne v_j$일 때 비용 발생: $i$에서 $j$로, $j$에서 $i$로 가는 비용 간선
        \item $v_i$가 T면 $v_j$도 T여야 함: $i$에서 $j$로 가는 무한 간선
        \item $v_i$가 F면 $v_j$도 F여야 함: $j$에서 $i$로 가는 무한 간선
    \end{enumerate}
    \item 5/6번 + $v_i$와 $v_j$가 달라야 한다는 조건이 있으면 MAX-2SAT
    \item Maximum Density Subgraph (NEERC'06H, BOJ 3611 팀의 난이도)
    \begin{enumerate}
        \item density $\geq x$인 subgraph가 있는지 이분 탐색
        \item 정점 $N$개, 간선 $M$개, 차수 $D_i$개
        \item 그래프의 간선마다 용량 1인 양방향 간선 추가
        \item 소스에서 정점으로 용량 $M$, 정점에서 싱크로 용량 $M-D_i+2x$
        \item min cut에서 S와 붙어 있는 애들이 1개 이상이면 x 이상이고, 그게 subgraph의 정점들
        \item while(r-l $\geq$ 1.0/(n*n)) 으로 해야 함. 너무 많이 돌리면 실수 오차
    \end{enumerate}
\end{itemize}

\end{document}